import 'dart:async'; // Importing the dart:async library for asynchronous operations like Timers.
import 'dart:math'; // Importing the dart:math library for mathematical constants and functions like pi and min.

import 'package:flutter/material.dart'; // Importing the Flutter material library for building UI components.

/// A widget that displays a carousel of cards with interactive animations.
///
/// This widget allows users to swipe horizontally through a stack of cards.
/// It provides a visually engaging way to present a list of items,
/// with animations for card movement, rotation, and scaling.
///
/// Comments are automaticaly generated by Gemini AI.
class CardCarouselWidget<Playlist> extends StatefulWidget {
  /// The list of data to be displayed as cards in the carousel.
  final List<Playlist> cardData;

  /// The duration of the card swipe animation.
  final Duration animationDuration;

  /// The duration of the animation when scrolling down (e.g., bouncing back).
  final Duration downScrollDuration;

  /// The duration of the card stack animation (if enabled).
  final Duration stackDuration;

  /// The maximum distance the card can be scrolled horizontally before triggering a card change.
  final double maxScrollDistance;

  /// The limit for downward scroll offset, beyond which card block vibration might occur.
  final double scrollDownLimit;

  /// The threshold value (0.0 to 1.0) of the animation controller at which a card is considered to be moved to the next position.
  final double thresholdValue;

  /// Callback function invoked when the card changes (i.e., after a successful swipe).
  final void Function(int)? onCardChange;

  /// Builder function to create the widget for each card in the carousel.
  ///
  /// [context] is the build context.
  /// [index] is the index of the card data in the [cardData] list.
  /// [visibleIndex] is the index of the card in the visible carousel stack (0 for top card, 1 for second, etc.).
  final Widget Function(BuildContext context, int index, int visibleIndex)
      cardBuilder;

  /// A boolean flag to trigger the card stack animation.
  final bool shouldStartCardStackAnimation;

  /// Callback function invoked when the card stack animation completes.
  final void Function(bool value) onCardStackAnimationComplete;

  /// Starting horizontal offset of the top card.
  final double topCardOffsetStart;

  /// Ending horizontal offset of the top card during animation.
  final double topCardOffsetEnd;

  /// Starting scale of the top card.
  final double topCardScaleStart;

  /// Ending scale of the top card during animation.
  final double topCardScaleEnd;

  /// Vertical drop offset of the top card during animation.
  final double topCardYDrop;

  /// Starting horizontal offset of the second card.
  final double secondCardOffsetStart;

  /// Ending horizontal offset of the second card during animation.
  final double secondCardOffsetEnd;

  /// Starting scale of the second card.
  final double secondCardScaleStart;

  /// Ending scale of the second card during animation.
  final double secondCardScaleEnd;

  /// Constructor for the [CardCarouselWidget].
  const CardCarouselWidget({
    required this.cardData,
    required this.cardBuilder,
    this.animationDuration = const Duration(milliseconds: 800),
    this.downScrollDuration = const Duration(milliseconds: 300),
    this.stackDuration = const Duration(milliseconds: 1000),
    this.maxScrollDistance = 220.0,
    this.scrollDownLimit = -40.0,
    this.thresholdValue = 0.3,
    this.onCardChange,
    this.topCardOffsetStart = 0.0,
    this.topCardOffsetEnd = 15.0,
    this.topCardScaleStart = 1.0,
    this.topCardScaleEnd = 0.9,
    this.topCardYDrop = 0.0,
    this.secondCardOffsetStart = 15.0,
    this.secondCardOffsetEnd = 0.0,
    this.secondCardScaleStart = 0.85,
    this.secondCardScaleEnd = 1.0,
    this.shouldStartCardStackAnimation = false,
    required this.onCardStackAnimationComplete,
    super.key,
  });

  @override
  State<CardCarouselWidget<Playlist>> createState() =>
      _CardCarouselWidgetState<Playlist>();
}

/// State class for the [CardCarouselWidget].
/// Manages the animation controllers, animations, and card widgets.
class _CardCarouselWidgetState<Playlist>
    extends State<CardCarouselWidget<Playlist>> with TickerProviderStateMixin {
  /// AnimationController for horizontal card swipe animation.
  AnimationController? _controller;

  /// Animation for vertical offset during card swipe.
  Animation<double>? _yOffsetAnimation;

  /// Animation for rotation during card swipe.
  Animation<double>? _rotationAnimation;

  /// Combined animation for smoother control.
  Animation<double>? _animation;

  /// AnimationController for the down scroll (bounce back) animation.
  AnimationController? _downScrollController;

  /// Animation for down scroll offset.
  Animation<double>? _downScrollAnimation;

  /// AnimationController for the initial card stack animation.
  AnimationController? _cardStackAnimationController;

  /// Animation for vertical offset during card stack animation.
  Animation<double>? _cardStackYOffsetAnimation;

  /// Starting value of the horizontal swipe animation.
  double _startAnimationValue = 0.0;

  /// Starting position of the horizontal drag gesture.
  double _scrollStartPosition = 0.0;

  /// Current horizontal scroll offset during drag.
  double _scrollOffset = 0.0;

  /// Flag to indicate if a card has been moved (swiped past halfway).
  bool _isCardMoved = false;

  /// Flag to indicate if the card swipe has reached the halfway point.
  bool _hasReachedHalf = false;

  /// Flag to prevent animation re-trigger during fast swipes.
  bool _isAnimationBlocked = false;

  /// Flag to control vibration feedback (if implemented).
  bool _shouldPlayVibration = true;

  /// Local copy of the card data, used for manipulation within the widget.
  late List<Playlist> _cardData;

  /// Timer to debounce card move actions, preventing rapid triggers.
  Timer? _debounceTimer;

  /// Widget for the top card in the stack.
  Widget? _topCardWidget;

  /// Index of the top card in the original [widget.cardData].
  int? _topCardIndex;

  /// Widget for the second card in the stack.
  Widget? _secondCardWidget;

  /// Index of the second card in the original [widget.cardData].
  int? _secondCardIndex;

  /// Widget for the third card in the stack (for visual depth).
  Widget? _thirdCardWidget;

  /// Index of the third card in the original [widget.cardData].
  int? _thirdCardIndex;

  /// Widget for the card that is popped out during swipe animation.
  Widget? _poppedCardWidget;

  /// Index of the popped card in the original [widget.cardData].
  int? _poppedCardIndex;

  /// Placeholder for vibration feedback on card move (implementation not provided).
  Future<void> onCardMoveVibration() async {}

  /// Placeholder for vibration feedback on card block (implementation not provided).
  Future<void> onCardBlockVibration() async {}

  @override
  void initState() {
    super.initState();

    // Initialize local card data from widget's data.
    _cardData = List.from(widget.cardData);

    // Initialize animation controller for horizontal swipe.
    _controller = AnimationController(
      duration: widget.animationDuration,
      vsync: this,
    );

    // Create a curved animation for smoother transitions.
    _animation = CurvedAnimation(
      parent: _controller ?? AnimationController(vsync: this),
      curve: Curves.easeInOut,
    );

    // Define a sequence of tweens for vertical offset animation.
    _yOffsetAnimation = TweenSequence<double>([
      TweenSequenceItem<double>(
        tween: Tween<double>(
            begin: 0.0,
            end: 0.5), // First half of animation: offset goes from 0 to 0.5
        weight: 45.0, // Weight in the sequence
      ),
      TweenSequenceItem<double>(
        tween: Tween<double>(
            begin: 0.5,
            end: 1.0), // Second half of animation: offset goes from 0.5 to 1.0
        weight: 55.0, // Weight in the sequence
      ),
    ]).animate(_animation ??
        const AlwaysStoppedAnimation(
            0.0)); // Animate using the curved animation

    // Define a sequence of tweens for rotation animation.
    _rotationAnimation = TweenSequence<double>([
      TweenSequenceItem<double>(
        tween: Tween<double>(
            begin: 0.0,
            end: -180.0), // First half: rotation from 0 to -180 degrees
        weight: 45.0, // Weight in the sequence
      ),
      TweenSequenceItem<double>(
        tween: Tween<double>(
            begin: -180.0,
            end: -180.0), // Second half: rotation stays at -180 degrees
        weight: 55.0, // Weight in the sequence
      ),
    ]).animate(_animation ??
        const AlwaysStoppedAnimation(
            0.0)); // Animate using the curved animation

    // Initialize animation controller for down scroll (bounce back).
    _downScrollController = AnimationController(
      duration: widget.downScrollDuration,
      vsync: this,
    );

    // Create animation for down scroll offset, initially set to 0.0.
    _downScrollAnimation = Tween<double>(
      begin: 0.0,
      end: 0.0,
    ).animate(_downScrollController ?? AnimationController(vsync: this))
      ..addListener(() {
        // Listener to update the scroll offset during down scroll animation.
        _scrollOffset = _downScrollAnimation?.value ?? 0.0;
      });

    // Add listener to the main animation controller to handle card movement logic.
    _controller?.addListener(() {
      if (_cardData.length > 1) {
        // Check if card swipe animation is past halfway and card hasn't been moved yet.
        if (!_isCardMoved && (_controller?.value ?? 0.0) >= 0.5) {
          // Debounce to prevent rapid card moves.
          if (_debounceTimer?.isActive ?? false) {
            _isCardMoved = true;
            return;
          }

          // Move the first card to the end of the data list.
          var firstCard = _cardData.removeAt(0);
          _poppedCardIndex =
              widget.cardData.indexOf(firstCard); // Store original index
          _poppedCardWidget = widget.cardBuilder(
              context, _poppedCardIndex ?? 0, -1); // Build popped card widget
          _cardData.add(firstCard); // Add the first card to the end
          onCardMoveVibration(); // Trigger vibration feedback (if implemented)

          _isCardMoved = true; // Set flag to indicate card has been moved

          _updateCardWidgets(); // Update the card widgets to reflect the new order

          // Invoke the onCardChange callback if provided.
          if (widget.onCardChange != null) {
            widget.onCardChange?.call(widget.cardData.indexOf(_cardData[0]));
          }

          // Set a debounce timer to prevent immediate re-triggering.
          _debounceTimer = Timer(const Duration(milliseconds: 300), () {});
        }

        // Reset flags and animation controller when animation completes.
        if ((_controller?.value ?? 0.0) == 1.0) {
          _isCardMoved = false;
          _controller?.reset();
          _hasReachedHalf = false;
        }
      } else {
        // If only one or zero cards, reset the animation controller.
        _controller?.reset();
      }
    });

    // Initialize card stack animation if shouldStartCardStackAnimation is true.
    if (widget.shouldStartCardStackAnimation) {
      _cardStackAnimationController = AnimationController(
        duration: widget.stackDuration,
        vsync: this,
      );

      // Create animation for vertical offset during card stack animation.
      _cardStackYOffsetAnimation = Tween<double>(
        begin: 0.0,
        end: 1.0,
      ).animate(CurvedAnimation(
        parent:
            _cardStackAnimationController ?? AnimationController(vsync: this),
        curve: Curves.easeOutCubic,
      ));

      // Start the card stack animation and invoke callback on completion.
      _cardStackAnimationController
          ?.forward()
          .then((_) => widget.onCardStackAnimationComplete(false));
    }

    // Initialize card widgets based on the initial card data.
    _updateCardWidgets();
  }

  /// Updates the widgets for the top, second, and third cards based on the current [_cardData].
  void _updateCardWidgets() {
    if (_cardData.isNotEmpty) {
      _topCardIndex =
          widget.cardData.indexOf(_cardData[0]); // Index in original data
      _topCardWidget = widget.cardBuilder(
          context, _topCardIndex ?? 0, 0); // Build top card widget
    } else {
      _topCardIndex = null;
      _topCardWidget = null;
    }

    if (_cardData.length > 1) {
      _secondCardIndex =
          widget.cardData.indexOf(_cardData[1]); // Index in original data
      _secondCardWidget = widget.cardBuilder(
          context, _secondCardIndex ?? 0, 1); // Build second card widget
    } else {
      _secondCardIndex = null;
      _secondCardWidget = null;
    }

    if (_cardData.length > 2) {
      _thirdCardIndex =
          widget.cardData.indexOf(_cardData[2]); // Index in original data
      _thirdCardWidget = widget.cardBuilder(
          context, _thirdCardIndex ?? 0, 2); // Build third card widget
    } else {
      _thirdCardIndex = null;
      _thirdCardWidget = null;
    }
  }

  /// Overridden method to handle widget updates and prevent rebuilds if card data is unchanged.
  @override
  void didUpdateWidget(CardCarouselWidget<Playlist> oldWidget) {
    super.didUpdateWidget(oldWidget);

    // Check if the card data has actually changed (content comparison).
    bool cardDataChanged = false;
    if (widget.cardData.length != oldWidget.cardData.length) {
      cardDataChanged = true;
    } else {
      for (int i = 0; i < widget.cardData.length; i++) {
        if (widget.cardData[i] != oldWidget.cardData[i]) {
          cardDataChanged = true;
          break;
        }
      }
    }

    // If card data changed, reset animation and update card widgets.
    if (cardDataChanged) {
      _controller?.stop();
      _downScrollController?.stop();

      _cardData = List.from(widget.cardData);
      _isCardMoved = false;
      _hasReachedHalf = false;
      _startAnimationValue = 0.0;
      _scrollStartPosition = 0.0;
      _scrollOffset = 0.0;

      _controller?.reset();
      _downScrollController?.reset();

      _updateCardWidgets();
    }

    // Handle changes in shouldStartCardStackAnimation flag.
    if (widget.shouldStartCardStackAnimation !=
        oldWidget.shouldStartCardStackAnimation) {
      if (widget.shouldStartCardStackAnimation) {
        _cardStackAnimationController = AnimationController(
          duration: const Duration(milliseconds: 1000),
          vsync: this,
        );

        _cardStackYOffsetAnimation = Tween<double>(
          begin: 0.0,
          end: 1.0,
        ).animate(CurvedAnimation(
          parent:
              _cardStackAnimationController ?? AnimationController(vsync: this),
          curve: Curves.easeOutCubic,
        ));

        _cardStackAnimationController
            ?.forward()
            .then((_) => widget.onCardStackAnimationComplete(false));
      } else {
        _cardStackAnimationController?.dispose();
        _cardStackAnimationController = null;
        _cardStackYOffsetAnimation = null;
      }
    }
  }

  @override
  void dispose() {
    // Dispose of animation controllers and timer to prevent memory leaks.
    _controller?.dispose();
    _downScrollController?.dispose();
    _debounceTimer?.cancel();
    _cardStackAnimationController?.dispose();
    super.dispose();
  }

  /// Handles the start of a horizontal drag gesture.
  void _onHorizontalDragStart(DragStartDetails details) {
    // Ignore drag if animations are running, stack animation is active, or only one card is present.
    if (_controller?.isAnimating == true ||
        _downScrollController?.isAnimating == true ||
        widget.shouldStartCardStackAnimation ||
        _cardData.length == 1) {
      return;
    }
    _isAnimationBlocked = false; // Reset animation block flag
    _startAnimationValue =
        _controller?.value ?? 0.0; // Store current animation value
    _scrollStartPosition =
        details.globalPosition.dx; // Record starting drag position
    _controller?.stop(canceled: false); // Stop horizontal swipe animation
    _downScrollController?.stop(); // Stop down scroll animation
    _hasReachedHalf = false; // Reset halfway flag
  }

  /// Handles updates during a horizontal drag gesture.
  void _onHorizontalDragUpdate(DragUpdateDetails details) {
    // Ignore drag updates if animations are running, halfway point reached, stack animation active, animation blocked, or only one card.
    if (_controller?.isAnimating == true ||
        _downScrollController?.isAnimating == true ||
        _hasReachedHalf ||
        widget.shouldStartCardStackAnimation ||
        _isAnimationBlocked ||
        _cardData.length == 1) {
      return;
    }
    if (_hasReachedHalf) {
      return;
    }

    // Calculate horizontal scroll distance based on drag gesture.
    double scrollDistance = _scrollStartPosition - details.globalPosition.dx;

    // Handle right swipe (positive scroll distance).
    if (scrollDistance >= 0) {
      // Calculate scroll fraction and update animation controller value.
      double scrollFraction = scrollDistance / widget.maxScrollDistance;
      double newValue = (_startAnimationValue + scrollFraction)
          .clamp(0.0, 1.0); // Clamp value between 0 and 1
      if (_controller != null) {
        _controller?.value = newValue; // Set animation controller value
      }
      _scrollOffset = 0.0; // Reset down scroll offset

      // Check if the card swipe has reached halfway point.
      if ((_controller?.value ?? 0.0) >= 0.5 && !_hasReachedHalf) {
        _hasReachedHalf = true; // Set halfway flag
        final double remaining = 1.0 -
            (_controller?.value ??
                0.0); // Calculate remaining animation progress
        final int duration =
            ((_controller?.duration?.inMilliseconds ?? 0) * remaining)
                .round(); // Calculate remaining duration
        if (duration > 0) {
          _controller?.animateTo(1.0, // Animate to the end
              duration: Duration(milliseconds: duration),
              curve: Curves.easeOut); // Use ease-out curve
          _isAnimationBlocked =
              true; // Block further animation triggers until complete
        } else {
          if (_controller != null) {
            _controller?.value =
                1.0; // Directly set to end if duration is too short
          }
        }
      }
    }
    // Handle left swipe (negative scroll distance - down scroll/bounce back effect).
    else {
      if (_controller != null) {
        _controller?.value =
            _startAnimationValue; // Reset horizontal swipe animation value
      }
      // Clamp down scroll offset to the defined limit.
      double downScrollOffset =
          scrollDistance.clamp(widget.scrollDownLimit, 0.0);
      _scrollOffset =
          -downScrollOffset; // Set down scroll offset for visual effect

      // Trigger card block vibration if down scroll limit is reached (if vibration is implemented).
      if (downScrollOffset == widget.scrollDownLimit) {
        if (_shouldPlayVibration) {
          onCardBlockVibration(); // Trigger block vibration (if implemented)
          _shouldPlayVibration = false; // Prevent repeated vibration triggers
        }
      }
    }
  }

  /// Handles the end of a horizontal drag gesture.
  void _onHorizontalDragEnd(DragEndDetails details) {
    // Ignore drag end if animations are running, stack animation active, animation blocked or only one card.
    if (_controller?.isAnimating == true ||
        _downScrollController?.isAnimating == true ||
        widget.shouldStartCardStackAnimation ||
        _isAnimationBlocked ||
        _cardData.length == 1) {
      return;
    }
    // Animate down scroll offset back to 0 if there was a down scroll.
    if (_scrollOffset != 0.0) {
      _downScrollAnimation = Tween<double>(
        begin: _scrollOffset,
        end: 0.0,
      ).animate(CurvedAnimation(
        parent: _downScrollController ?? AnimationController(vsync: this),
        curve: Curves.easeOutCubic,
      ));
      _downScrollController?.forward(from: 0.0); // Start down scroll animation
    }
    // Handle horizontal swipe animation completion.
    else if (!_hasReachedHalf) {
      // If swipe is past the threshold, animate to the next card.
      if ((_controller?.value ?? 0.0) >= widget.thresholdValue) {
        final double remaining = 1.0 -
            (_controller?.value ??
                0.0); // Calculate remaining animation progress
        final int duration =
            ((_controller?.duration?.inMilliseconds ?? 0) * remaining)
                .round(); // Calculate remaining duration
        if (duration > 0) {
          _controller?.animateTo(1.0, // Animate to the end
              duration: Duration(milliseconds: duration),
              curve: Curves.easeOut); // Use ease-out curve
          _isAnimationBlocked =
              true; // Block further animation triggers until complete
        } else {
          if (_controller != null) {
            _controller?.value =
                1.0; // Directly set to end if duration is too short
          }
        }
      }
      // If swipe is below the threshold, animate card back to original position.
      else {
        final int duration = ((_controller?.duration?.inMilliseconds ?? 0) *
                (_controller?.value ?? 0.0))
            .round(); // Calculate duration for back animation
        if (duration > 0) {
          _controller?.animateBack(0.0, // Animate back to start
              duration: Duration(milliseconds: duration),
              curve: Curves.easeOut); // Use ease-out curve
        } else {
          if (_controller != null) {
            _controller?.value =
                0.0; // Directly set to start if duration is too short
          }
        }
      }
    }
    _shouldPlayVibration = true; // Re-enable vibration for next swipe
  }

  @override
  Widget build(BuildContext context) {
    return RepaintBoundary(
      // RepaintBoundary for performance optimization
      child: GestureDetector(
        // GestureDetector to detect horizontal drag gestures
        onHorizontalDragStart: _onHorizontalDragStart, // Handle drag start
        onHorizontalDragUpdate: _onHorizontalDragUpdate, // Handle drag update
        onHorizontalDragEnd: _onHorizontalDragEnd, // Handle drag end
        child: AnimatedBuilder(
          // AnimatedBuilder to rebuild on animation changes
          animation: Listenable.merge([
            // Merge animation controllers to rebuild on any animation change
            _controller ?? AnimationController(vsync: this),
            _downScrollController ?? AnimationController(vsync: this),
            if (widget
                .shouldStartCardStackAnimation) // Include stack animation controller if animation is active
              _cardStackAnimationController ?? AnimationController(vsync: this),
          ]),
          builder: (context, child) {
            // Get animation values for current frame.
            double yOffsetAnimationValue = _yOffsetAnimation?.value ?? 0.0;
            double rotation = _rotationAnimation?.value ?? 0.0;
            // Calculate total horizontal offset for the top card.
            double totalXOffset = widget.topCardOffsetStart -
                yOffsetAnimationValue * widget.maxScrollDistance +
                (_downScrollController?.isAnimating == true
                    ? _downScrollAnimation?.value ?? 0.0
                    : _scrollOffset);
            // Calculate total vertical offset for the top card.
            double totalYOffset =
                (_controller?.value ?? 0.0) * widget.topCardYDrop;

            List<Widget> stackChildren =
                []; // List to hold card widgets in the stack

            // Handle case with only one card (or zero).
            if (_cardData.length == 1) {
              stackChildren.add(_topCardWidget ??
                  const SizedBox.shrink()); // Add top card if available
            }
            // Handle case with multiple cards (stack effect).
            else {
              int cardCount =
                  min(_cardData.length, 3); // Display max 3 cards in stack

              // Build card stack based on whether a card is being moved.
              if (_isCardMoved) {
                // If card moved, build stack with popped card at the top.
                for (int i = 0; i < cardCount; i++) {
                  if (i == 0) {
                    stackChildren.add(buildTopCard(totalXOffset, rotation,
                        totalYOffset)); // Build top card with animations
                  } else {
                    stackChildren.add(
                        buildCard(cardCount - i)); // Build subsequent cards
                  }
                }
              } else {
                // If card not moved, build stack with normal order.
                for (int i = cardCount - 1; i >= 0; i--) {
                  if (i == 0) {
                    stackChildren.add(buildTopCard(totalXOffset, rotation,
                        totalYOffset)); // Build top card with animations
                  } else {
                    stackChildren.add(buildCard(i)); // Build subsequent cards
                  }
                }
              }
            }

            return Stack(
              // Stack widget to layer cards on top of each other
              alignment: Alignment.center, // Center alignment for the stack
              children:
                  stackChildren, // Add the built card widgets to the stack
            );
          },
        ),
      ),
    );
  }

  /// Builds the top card widget with animation transformations.
  Widget buildTopCard(double xOffset, double rotation, double yOffset) {
    if (_topCardWidget == null) {
      return const SizedBox
          .shrink(); // Return empty SizedBox if top card widget is null
    }

    // Determine which widget to use for the top card (either current top card or popped card during animation).
    Widget cardWidget = _isCardMoved && _cardData.length > 1
        ? (_poppedCardWidget ?? const SizedBox.shrink())
        : (_topCardWidget ?? const SizedBox.shrink());

    return AnimatedBuilder(
      // AnimatedBuilder for animating top card properties
      animation: _controller ??
          const AlwaysStoppedAnimation(
              0.0), // Animate based on main animation controller
      builder: (context, child) {
        double scale; // Variable to hold scale value for the top card

        double controllerValue =
            _controller?.value ?? 0.0; // Get current animation controller value

        // Scale animation logic based on number of cards and animation progress.
        if (_cardData.length == 2) {
          if (controllerValue <= 0.5 && _cardData.length > 1) {
            if (controllerValue >= 0.45) {
              double progress = (controllerValue - 0.45) /
                  0.05; // Calculate animation progress in a smaller range
              scale = 1.0 -
                  0.05 *
                      progress; // Scale down slightly as animation progresses
            } else {
              scale = 1.0; // Full scale before threshold
            }
          } else {
            scale = 0.95; // Slightly smaller scale after threshold
          }
        } else {
          if (controllerValue <= 0.5 && _cardData.length > 1) {
            if (controllerValue >= 0.4) {
              double progress = (controllerValue - 0.4) /
                  0.1; // Calculate animation progress in a smaller range
              scale = 1.0 -
                  0.1 * progress; // Scale down slightly as animation progresses
            } else {
              scale = 1.0; // Full scale before threshold
            }
          } else {
            scale = 0.9; // Smaller scale after threshold
          }
        }

        return Transform(
          // Apply transformations to the top card widget
          alignment: Alignment.center, // Center alignment for transformations
          transform: Matrix4.identity() // Start with identity matrix
            ..translate(
                xOffset, yOffset) // Apply horizontal and vertical offset
            ..translate(
                0.0,
                _isCardMoved
                    ? (-widget.secondCardOffsetStart) *
                        (((_rotationAnimation?.value ?? 0) + 180) /
                            90) // Apply additional vertical offset during card move
                    : 0)
            ..setEntry(3, 2, 0.001) // Perspective effect
            ..rotateZ(rotation * pi / 2800) // Apply rotation around Z-axis
            ..scale(scale, scale), // Apply scale transformation
          child: AnimatedOpacity(
            // Animate opacity for fade-out effect during swipe
            opacity: controllerValue >= 0.5
                ? 1 - controllerValue
                : 1, // Opacity based on animation progress
            duration: const Duration(milliseconds: 500), // Fade duration
            child: child, // Apply opacity to the card widget
          ),
        );
      },
      child:
          cardWidget, // Child widget is the actual card widget built by cardBuilder
    );
  }

  /// Builds the second and third card widgets with animation transformations.
  Widget buildCard(int index) {
    // Return empty SizedBox if not enough cards or index is out of bounds.
    if (_cardData.length <= 1 || index >= _cardData.length) {
      return const SizedBox.shrink();
    }

    Widget? cardWidget; // Variable to hold the card widget

    // Determine which card widget to use based on index and card movement state.
    if (_isCardMoved) {
      if (index == 1) {
        cardWidget =
            _topCardWidget; // If card moved, index 1 is the previous top card
      } else if (index == 2) {
        cardWidget =
            _secondCardWidget; // If card moved, index 2 is the previous second card
      } else {
        return const SizedBox.shrink(); // Return empty for other indices
      }
    } else {
      if (index == 1) {
        cardWidget = _secondCardWidget; // Index 1 is the second card
      } else if (index == 2) {
        cardWidget = _thirdCardWidget; // Index 2 is the third card
      } else {
        return const SizedBox.shrink(); // Return empty for other indices
      }
    }

    if (cardWidget == null) {
      return const SizedBox.shrink(); // Return empty if card widget is null
    }

    return AnimatedBuilder(
      // AnimatedBuilder for animating card properties
      animation: _controller ??
          const AlwaysStoppedAnimation(
              0.0), // Animate based on main animation controller
      builder: (context, child) {
        double initialOffset = 0.0; // Initial vertical offset
        double initialScale = 1.0; // Initial scale
        double targetScale = 1.0; // Target scale

        double controllerValue =
            _controller?.value ?? 0.0; // Get current animation controller value

        // Define initial offset and scale based on card index and number of cards.
        if (_cardData.length == 2) {
          if (index == 1) {
            initialOffset = widget
                .secondCardOffsetStart; // Offset for second card in 2-card stack
            initialScale = widget
                .secondCardScaleStart; // Scale for second card in 2-card stack
            targetScale = widget
                .secondCardScaleEnd; // Target scale for second card in 2-card stack
          }
        } else {
          if (index == 0) {
            initialOffset =
                widget.topCardOffsetStart; // Offset for (incorrect index)
          }
          if (index == 1) {
            initialOffset = widget
                .secondCardOffsetStart; // Offset for second card in 3+ card stack
            initialScale = widget
                .secondCardScaleStart; // Scale for second card in 3+ card stack
            targetScale = widget
                .secondCardScaleEnd; // Target scale for second card in 3+ card stack
          } else if (index == 2) {
            initialOffset = widget
                .secondCardOffsetStart; // Offset for third card in 3+ card stack
            initialScale = widget
                .secondCardScaleStart; // Scale for third card in 3+ card stack
            targetScale = widget
                .secondCardScaleStart; // Target scale for third card in 3+ card stack
          }
        }

        double yOffset = initialOffset; // Vertical offset variable
        double scale = initialScale; // Scale variable

        // Animation logic for cards other than the top card, based on animation progress.
        if (controllerValue <= 0.5) {
          double progress =
              controllerValue / 0.5; // Animation progress for first half

          if (_cardData.length == 2) {
            yOffset = initialOffset -
                widget.secondCardOffsetStart *
                    progress; // Animate vertical offset for 2-card stack
          } else {
            yOffset = index >= 2
                ? initialOffset
                : initialOffset -
                    widget.secondCardOffsetStart *
                        progress; // Animate vertical offset for 3+ card stack
          }
          progress = Curves.easeOut
              .transform(progress); // Apply ease-out curve to progress

          scale = initialScale; // Scale remains constant in first half
        } else {
          double progress = (controllerValue - 0.5) /
              0.5; // Animation progress for second half

          if (_cardData.length == 2) {
            yOffset = initialOffset -
                widget.secondCardOffsetStart +
                widget.secondCardOffsetEnd *
                    progress; // Animate vertical offset for 2-card stack in second half
          } else {
            yOffset = index >= 2
                ? initialOffset
                : initialOffset -
                    widget.secondCardOffsetStart +
                    widget.secondCardOffsetEnd *
                        progress; // Animate vertical offset for 3+ card stack in second half
          }
          progress = Curves.easeOut
              .transform(progress); // Apply ease-out curve to progress

          scale = initialScale +
              (targetScale - initialScale) *
                  progress; // Animate scale in second half
        }

        return Transform(
          // Apply transformations to card widget
          alignment: Alignment.center, // Center alignment for transformations
          transform: Matrix4.identity() // Start with identity matrix
            ..translate(
                widget.shouldStartCardStackAnimation &&
                        _cardStackYOffsetAnimation != null
                    ? _cardStackYOffsetAnimation // Apply stack animation offset if active
                            ?.drive(CurveTween(
                                curve: Interval((0.4 * (index - 1)),
                                    0.9))) // Interval curve for staggered animation
                            .drive(CurveTween(
                                curve: Curves.easeOut)) // Ease-out curve
                            .drive(Tween(
                                begin: yOffset,
                                end: yOffset +
                                    20)) // Animate vertical offset during stack animation
                            .value ??
                        0 // Default to 0 if animation value is null
                    : yOffset, // Apply normal vertical offset
                0.0)
            ..scale(scale, scale), // Apply scale transformation
          child:
              child, // Child widget is the actual card widget built by cardBuilder
        );
      },
      child:
          cardWidget, // Child widget is the actual card widget built by cardBuilder
    );
  }
}
